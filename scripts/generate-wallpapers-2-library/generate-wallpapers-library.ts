#!/usr/bin/env ts-node

import chalk from 'chalk';
import commander from 'commander';
import { readFile, writeFile } from 'fs/promises';
import glob from 'glob-promise';
import moment from 'moment';
import { normalizeTo_camelCase } from 'n12';
import { capitalize } from 'n12/dist/capitalize';
import { basename, dirname, join, relative } from 'path';
import { IWallpaperMetadata } from '../../assets/ai/wallpaper/IWallpaperComponent';
import { commit } from '../utils/autocommit/commit';
import { isWorkingTreeClean } from '../utils/autocommit/isWorkingTreeClean';
import { forPlay } from '../utils/forPlay';
import { generateImport } from '../utils/generateImport';
import { isFileExisting } from '../utils/isFileExisting';
import { organizeImports } from '../utils/organizeImports';
import { prettify } from '../utils/prettify';

if (process.cwd() !== join(__dirname, '../..')) {
    console.error(chalk.red(`CWD must be root of the project`));
    process.exit(1);
}

const program = new commander.Command();
program.option('--commit', `Autocommit changes`);
program.parse(process.argv);
const { commit: isCommited } = program.opts();

generateWallpapersLibrary({ isCommited })
    .catch((error) => {
        console.error(chalk.bgRed(error.name));
        console.error(error);
        process.exit(1);
    })
    .then(() => {
        process.exit(0);
    });

async function generateWallpapersLibrary({ isCommited }: { isCommited: boolean }) {
    console.info(`üñºÔ∏è  Generating wallpapers library`);

    if (isCommited && !(await isWorkingTreeClean(process.cwd()))) {
        throw new Error(`Working tree is not clean`);
    }

    const wallpapersDir = join(process.cwd(), 'assets', 'ai', 'wallpaper', 'gallery');
    const wallpapersPaths = await glob(
        join(wallpapersDir, '*.png' /* <- TODO: !!! Use here metadata files */).split('\\').join('/'),
    );
    const indexFilePath = join(wallpapersDir, '..', 'index.tsx');

    const wallpapers: Array<{ entityName: string; entityPath: string }> = [];

    const stats = {
        total: wallpapersPaths.length,
        done: -1,
        startTime: moment(),
    };
    for (const wallpaperPath of wallpapersPaths) {
        await forPlay();

        // TODO: [ü•º] Make just one util for stats
        stats.done++;
        const statsTotalString = `${stats.done}/${stats.total}`;
        const statsPercentString = `${Math.round((stats.done / stats.total) * 100)}%`;
        const elapsedTime = moment().diff(stats.startTime);
        const estimatedTime = (elapsedTime / stats.done) * (stats.total - stats.done);
        const statsTimeEstimateString =
            estimatedTime === Infinity ? '' : `${moment.duration(estimatedTime).humanize()} left`;
        const statsString = `${statsPercentString} ${statsTotalString} ${statsTimeEstimateString}`;

        console.info(chalk.bgGray(statsString) + ' ' + chalk.grey(`${wallpaperPath.split('\\').join('/')}`));

        const metadataPath = wallpaperPath.replace(/\.png$/, '.json');

        if (!(await isFileExisting(metadataPath))) {
            throw new Error(`Metadata file does not exist "${metadataPath}"`);
        }

        const metadata = JSON.parse(await readFile(metadataPath, 'utf8')) as IWallpaperMetadata;

        const name = basename(wallpaperPath);

        const jobUuidMatch = name.match(/_(?<jobUuid>[^_]*?)(\.png)?$/);
        const jobUuid = jobUuidMatch?.groups?.jobUuid;
        const componentId = jobUuid?.split('-')[0]!;

        if (!jobUuid) {
            throw new Error(`Can not find jobUuid in "${name}"`);
        }

        const jobUrl = new URL(`https://www.midjourney.com/app/jobs/${jobUuid}`);

        const nameWithoutExtension = name.replace(/\.png$/, '');

        const type = 'Image';
        const wallpaperFilePath = `${join(wallpapersDir, nameWithoutExtension)}_${type}.tsx`;

        const wallpaperFileOldContent = await readFile(wallpaperFilePath, 'utf8').catch(() => ``);

        if (
            wallpaperFileOldContent.includes(
                `@not-generated by generate-wallpapers-library`,
            ) /* <- TODO: Do not use this mechanism - when file exists just always skip and generate only new files */
        ) {
            console.info(`‚è© ${relative(process.cwd(), wallpaperFilePath).split('\\').join('/')}`);
            continue;
        }
        const nameWithoutBoilerplate = nameWithoutExtension.replace(/^Pavol_Hejn_/, '').replace('_' + jobUuid, '');

        const componentName = capitalize(normalizeTo_camelCase(nameWithoutBoilerplate)) + `_${componentId}_` + type;

        const wallpaperImportPath = (
            './' + relative(dirname(wallpaperFilePath), wallpaperPath).split('\\').join('/')
        ).replace(/^\.\/\.\.\//, '../');

        const metadataImportPath = wallpaperImportPath.replace(/\.png$/, '.json');
        const textsImportPath = wallpaperImportPath.replace(/\.png$/, '.texts.json');
        const colorStatsImportPath = wallpaperImportPath.replace(/\.png$/, '.colors.json');

        wallpapers.push({ entityName: componentName, entityPath: wallpaperFilePath });

        const wallpaperFileContent = await Promise.resolve(
            `

            /**
             * üè≠ GENERATED WITH üñºÔ∏è Generate wallpapers library
             * ‚ö†Ô∏è Warning: Do not edit by hand, all changes will be lost on next execution!
             *    If you want to edit this file:
             *      - Change @generated to @not-generated
             *      - And remove this warning
             *    Then the file will not be re-generated automatically
             */

            // TODO: !!! Newly sort imports

            import Image from 'next/image';
            import { hydrateColorStats } from '../../../../src/utils/image/utils/hydrateColorStats';
            // import { Color } from '../../../../src/utils/color/Color';
            // import { IImageColorStats } from '../../../../src/utils/image/utils/IImageColorStats';
            import { IWallpaperMetadata, IWallpaperTexts, IWallpaperComponentProps } from '../IWallpaperComponent';
            import colorStats from '${colorStatsImportPath}'
            import metadata from '${metadataImportPath}';
            import source from '${wallpaperImportPath}';
            import texts from '${textsImportPath}';


            /**
             * Image of ${metadata.prompt}
             *
             * @see ${jobUrl.href}
             * @generated by generate-wallpapers-library
             */
            export function ${componentName}(props: IWallpaperComponentProps) {

                const { width, quality } = props;

                return (
                    <Image
                        alt="${metadata.prompt}"
                        src={source}
                        draggable="false"
                        placeholder="blur"
                        height={Math.round(width/1920*1080)}
                        style={{ objectFit: 'cover', width: '100%', height: '100%' }}
                        {...{ width, quality }}
                    />
                );
            }

            ${componentName}.metadata = metadata satisfies IWallpaperMetadata;
            ${componentName}.colorStats = hydrateColorStats(colorStats);
            ${componentName}.texts = texts satisfies IWallpaperTexts;
        `,
        )
            .then((content) => {
                // Remove comment lines
                return content.split(/^(?:\s*\/\/.*\n)+/gm).join('');
            })
            .then(
                prettify,
            ); /* .then(organizeImports) <- Note: Imports are organized here AND its pretty performance heavy to do it each time */

        await writeFile(wallpaperFilePath, wallpaperFileContent, 'utf8');
        console.info(`üíæ ${relative(process.cwd(), wallpaperFilePath).split('\\').join('/')}`);

        break;
    }

    const indexFileContent = await Promise.resolve(
        `

            /**
             * üè≠ GENERATED WITH üñºÔ∏è Generate wallpapers library
             * ‚ö†Ô∏è Warning: Do not edit by hand, all changes will be lost on next execution!
             */

            ${wallpapers
                .map((options) => generateImport({ ...options, itselfPath: indexFilePath, isNamedImport: true }))
                .join('\n')}
            import { IWallpaperComponent } from './IWallpaperComponent';


            export const generated_wallpapers: Array<IWallpaperComponent> = [${wallpapers
                .map(({ entityName }) => entityName)
                .join(',')}];
        `,
    )
        .then(prettify)
        .then(organizeImports);

    await writeFile(indexFilePath, indexFileContent, 'utf8');

    if (isCommited) {
        await commit(dirname(wallpapersDir), `üñºÔ∏è Generate wallpapers library`);
    }

    console.info(`[ Done üñºÔ∏è  Generating wallpapers library ]`);
}

/**
 * TODO: Maybe use getMidjourneyLink from batch-froject-editor
 * TODO: Persistency and uniqueness of the names
 */
