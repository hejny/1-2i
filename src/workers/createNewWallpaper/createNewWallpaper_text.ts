import { FONTS } from '../../../config';
import { getExecutionTools } from '../../ai/prompt-templates/getExecutionTools';
import { webgptPtpLibrary } from '../../ai/prompt-templates/webgptPtpLibrary';
import { addFontToContent } from '../../components/ImportFonts/addFontToContent';
import { TaskProgress } from '../../components/TaskInProgress/task/TaskProgress';
import type { WriteWallpaperPromptResponse } from '../../pages/api/custom/write-wallpaper-prompt';
import { randomItem } from '../../utils/randomItem';
import {
    description,
    string_markdown,
    string_name,
    string_translate_language,
    string_url,
    string_url_image,
    title,
    uuid,
} from '../../utils/typeAliases';

export interface CreateNewWallpaperTextRequest {
    /**
     * The language
     * - It is used to select the right prompt template pipeline
     * - The interaction with the user is in this language
     * - The generated content is in this language
     */
    locale: string_translate_language;

    /**
     * Title of the wallpaper
     *
     * If set, the generated content will start with this title
     * If null, it will be written by AI
     */
    readonly title: Exclude<title, JSX.Element> | null;

    /**
     * Author of the wallpaper
     * Note: It must be valid client ID and same as identity of the user
     */
    readonly author: uuid;

    /**
     * Description of the wallpaper
     * It can be:
     * - **prompt** from MidJouener
     * - **alt** text
     * - **null**, in that case it will be generated by AI
     *
     * Note: There are two simmilar properties, provide only one of them:
     * - `description` which describes content of the image
     * - `assigment` which describes requirements for the page
     */
    readonly description: Exclude<description, JSX.Element> | null;

    /**
     * URL of the wallpaper in our CDN
     */
    readonly wallpaperUrl?: string_url_image;

    /**
     * Assigment of the wallpaper
     *
     * It is the detailed description of the wallpaper, please include information like:
     * - What is the page about
     * - What is the goal of the page
     * - What is the user supposed to do on the page
     *
     * Note: There are two simmilar properties, provide only one of them:
     * - `description` which describes content of the image
     * - `assigment` which describes requirements for the page
     */
    readonly assigment?: Exclude<description, JSX.Element> | null;

    /**
     * Additional sections to be added to the content
     */
    readonly addSections: Array<{
        /**
         * Unique name of the section
         * Note: It is used for example as element ID to lead anchor links to this section
         */
        readonly name: string_name;

        /**
         * Title of the section
         */
        readonly title: Exclude<title, JSX.Element>;

        /**
         * Order of the section
         * TODO: [ðŸ§ ] Some transparent system to order sections
         */
        readonly order: number;

        /**
         * Content of the section
         */
        readonly content: string_markdown;

        // <- TODO: !! [ðŸ§ ] Maybe allow to have empty name+title+content just write assigment and auto generate
    }>;

    /**
     * Links to be added to the content
     */
    readonly links: Array<{
        /**
         * Title of the link - it is used as link text and also as title attribute
         */
        readonly title: Exclude<title, JSX.Element>;

        /**
         * URL of the link
         */
        readonly url: string_url;
    }>;
}

export interface CreateNewWallpaperTextResult {
    /**
     * URL of the wallpaper
     */
    readonly contentWithFont: string_markdown;
}

/**
 * Process text part for createNewWallpaper
 *
 * @private Use ONLY in createNewWallpaper
 */
export async function createNewWallpaper_text(
    request: CreateNewWallpaperTextRequest,
    onProgress: (taskProgress: TaskProgress) => void,
): Promise<CreateNewWallpaperTextResult> {
    const { locale, title, author, wallpaperUrl /* TODO: Use> links, addSections */ } = request;
    let { description } = request;

    //-------[ Content analysis: ]---

    if (description && wallpaperUrl) {
        throw new Error('Either description or wallpaperUrl must be provided, not both');
        //               <- TODO: [0] Maybe constrain this logic into CreateNewWallpaperTextRequest
    }

    if (!description && !wallpaperUrl) {
        throw new Error('Either description or wallpaperUrl must be provided');
        //               <- TODO: [0] Maybe constrain this logic into CreateNewWallpaperTextRequest
    }

    if (!description && wallpaperUrl) {
        await onProgress({
            name: 'write-wallpaper-prompt',
            title: 'Content analysis',
            isDone: false,
            // TODO: Make it more granular
        });

        const response = await fetch('/api/custom/write-wallpaper-prompt', {
            method: 'POST',
            body: JSON.stringify({ wallpaperUrl }),
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        });

        if (response.ok === false) {
            // TODO: [ðŸˆµ] If 4XX error, show also the message from json body
            throw new Error(`Content analysis failed with status ${response.status}`);
        }

        const { wallpaperDescription } = (await response.json()) as WriteWallpaperPromptResponse;
        description = wallpaperDescription;

        console.info({ description });
        await onProgress({
            name: 'write-wallpaper-prompt',
            isDone: true,
        });
    }

    //-------[ /Content analysis ]---
    //===========================================================================
    //-------[ Write content: ]---
    await onProgress({
        name: 'write-website-content',
        title: 'Copywriting',
        isDone: false,
        // TODO: Make it more granular
    });

    const writeWebsiteContentLocaleMap = {
        en: 'writeWebsiteContent',
        cs: 'writeWebsiteContentCs',
        /* <- TODO: [ðŸ‘§] Constrain key to only existing PTPs in the library */
    };

    const { content } = await webgptPtpLibrary.createExecutor(
        writeWebsiteContentLocaleMap[locale],
        getExecutionTools(author),
    )(
        {
            rawTitle:
                title || '' /* <- TODO: [ðŸ§ ] Make some system how to pass and default/condition undefined params */,
            rawAssigment: description!,

            /*
        TODO: !! Use in write-website-content-cs.ptbk.md and uncomment here
        links,
        addSections,
        */
        },
        onProgress,
    );

    await onProgress({
        name: 'write-website-content',
        isDone: true,
    });

    //-------[ /Write content ]---
    //===========================================================================
    //-------[ Picking font: ]---
    const font = randomItem(...FONTS /* <- TODO: [ðŸ§ ][ðŸ” ] Some better heurictic than pure random */);

    const contentWithFont = addFontToContent(
        content || '', // <- TODO: [ðŸ‘§] Strongly type the executors to avoid need of remove nullables whtn noUncheckedIndexedAccess in tsconfig.json
        font,
    );

    //-------[ /Picking font ]---
    //===========================================================================

    return { contentWithFont };
}
